<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcade Chase: Orthographic Drift</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #2d2d2d;
        }

        canvas {
            display: block;
        }

        .ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: monospace;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>

<body>
    <div class="ui">
        <h1 class="text-2xl font-bold text-yellow-400">DRIFT PROTOCOL</h1>
        <p class="text-sm text-gray-400">WASD / ARROWS to Drive</p>
        <p class="text-sm text-gray-400">SPACE to Brake</p>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on base

        // --- Configuration ---
        const CONFIG = {
            lightDir: { x: 1, y: 1 }, // Light coming from top-left (so shadow goes bottom-right)
            shadowColor: 'rgba(0, 0, 0, 0.4)',
            carColor: '#ef4444', // Red-500
            wheelColor: '#171717', // Neutral-900
            groundColor: '#333333',
            gridColor: '#404040',
            skidMarkColor: 'rgba(20, 20, 20, 0.3)',
            smokeColor: 'rgba(200, 200, 200, 0.5)',
        };

        // Normalize light direction
        const len = Math.sqrt(CONFIG.lightDir.x ** 2 + CONFIG.lightDir.y ** 2);
        CONFIG.lightDir.x /= len;
        CONFIG.lightDir.y /= len;

        // --- City System Configuration ---
        const CITY_CONFIG = {
            blockSize: 300,
            roadWidth: 140,
            buildingInset: 20
        };

        // Semantic District Generation (Deterministic)
        function getCityBlock(gx, gy) {
            // Simple deterministic hash
            const h = Math.abs(Math.sin(gx * 12.9898 + gy * 78.233) * 43758.5453) % 1;
            const dist = Math.sqrt(gx * gx + gy * gy);

            // District Types based on distance from center (0,0)
            let type, height, color, roofColor;

            if (dist < 4) {
                // Downtown (High density, tall)
                type = 'downtown';
                height = 120 + h * 200;
                color = h > 0.5 ? '#1e293b' : '#334155'; // Slate 800/700
                roofColor = h > 0.5 ? '#334155' : '#475569';
            } else if (dist < 8) {
                // Commercial (Medium)
                type = 'commercial';
                height = 60 + h * 100;
                color = h > 0.5 ? '#475569' : '#525252'; // Slate 600 / Neutral 600
                roofColor = h > 0.5 ? '#64748b' : '#737373';
            } else if (dist < 14) {
                // Residential (Low)
                type = 'residential';
                height = 30 + h * 50;
                color = '#78716c'; // Stone 500
                roofColor = '#a8a29e';
            } else {
                // Outskirts / Industrial
                if (h < 0.4) return null; // Empty lots
                type = 'industrial';
                height = 20 + h * 30;
                color = '#4b5563'; // Gray 600
                roofColor = '#6b7280';
            }

            return { height, color, roofColor, type, h };
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
        }

        // --- Game State ---
        let width, height;

        const camera = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0
        };

        const car = {
            x: 0,
            y: 0,
            width: 24,
            length: 44,
            angle: 0,          // Facing direction
            velocity: { x: 0, y: 0 },
            speed: 0,
            steerAngle: 0,     // Current wheel angle relative to car
            maxSteer: 0.6,     // ~35 degrees
            acceleration: 0.4,
            friction: 0.98,
            driftFactor: 0.92, // How much velocity aligns with facing (1.0 = no drift, 0.0 = ice)
            turnSpeed: 0.08,
            wheelBase: 28,
            trackWidth: 26,
            wheelWidth: 6,
            wheelLength: 12
        };

        const inputs = {
            up: false,
            down: false,
            left: false,
            right: false,
            brake: false
        };

        const particles = [];
        const skidMarks = []; // Persistent skid marks on the ground

        // Speed lines/dust particles for motion reference
        const dustParticles = Array.from({ length: 50 }, () => ({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            size: Math.random() * 2 + 1
        }));

        // --- Resize Handling ---
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Input Handling ---
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'w') inputs.up = true;
            if (e.key === 'ArrowDown' || e.key === 's') inputs.down = true;
            if (e.key === 'ArrowLeft' || e.key === 'a') inputs.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd') inputs.right = true;
            if (e.key === ' ') inputs.brake = true;
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'w') inputs.up = false;
            if (e.key === 'ArrowDown' || e.key === 's') inputs.down = false;
            if (e.key === 'ArrowLeft' || e.key === 'a') inputs.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd') inputs.right = false;
            if (e.key === ' ') inputs.brake = false;
        });

        // --- Math Helpers ---
        function lerp(a, b, t) { return a + (b - a) * t; }
        function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

        // --- Physics Engine ---
        function updatePhysics() {
            // 1. Input & Basic Handling
            const targetSteer = (inputs.right ? 1 : 0) - (inputs.left ? 1 : 0);

            // Steer logic: responsive but smooth
            // Higher speed = slower steering response (stability) unless drifting
            const steerSpeed = 0.2 - (Math.min(car.speed, 20) * 0.005);
            car.steerAngle = lerp(car.steerAngle, targetSteer * car.maxSteer, Math.max(0.05, steerSpeed));

            // Acceleration
            let throttle = 0;
            if (inputs.up) throttle = 1;
            if (inputs.down) throttle = -0.5;

            // Handbrake overrides throttle
            if (inputs.brake) throttle = 0;

            // 2. Motion Vectors
            const forwardX = Math.cos(car.angle);
            const forwardY = Math.sin(car.angle);
            const rightX = -Math.sin(car.angle);
            const rightY = Math.cos(car.angle);

            // 3. Current Velocity Analysis (Local Space)
            // Project world velocity onto car axes
            const currentFwdSpeed = car.velocity.x * forwardX + car.velocity.y * forwardY;
            const currentLatSpeed = car.velocity.x * rightX + car.velocity.y * rightY;

            // 4. Drift Logic
            // Arcade Drift Condition: Handbrake or high existing lateral slip
            // We want "Lateral Slip" to be the defining drift characteristic
            const absLatSpeed = Math.abs(currentLatSpeed);
            const isDrifting = inputs.brake || absLatSpeed > 1.5;

            // 5. Turning Physics (Yaw)
            if (car.speed > 0.1) {
                // Moving forward or backward?
                const dir = currentFwdSpeed > 0 ? 1 : -1;

                let turnMultiplier = 0.012; // Base turn rate
                if (isDrifting) {
                    turnMultiplier = 0.025; // Turn faster when drifting (oversteer ability)
                }

                // Apply rotation
                // We use car.speed to ensure we can't turn when stopped
                // But we clamp the effective speed for turning so high speed doesn't make it uncontrollable
                // However, arcade racers often allow CONSTANT turn rate regardless of speed if speed > threshold
                const effectiveTurnSpeed = Math.min(car.speed, 10);
                car.angle += car.steerAngle * effectiveTurnSpeed * turnMultiplier * dir;
            }

            // 6. Velocity Updates
            // Apply Engine Force (only forward)
            // If drifting, reduce useful forward traction slightly? Maybe not for arcade fun.
            const traction = inputs.brake ? 0 : 1;
            car.velocity.x += forwardX * throttle * car.acceleration * traction;
            car.velocity.y += forwardY * throttle * car.acceleration * traction;

            // 7. Friction & Slip
            // Forward Friction (Air resistance + Rolling resistance)
            car.velocity.x *= car.friction;
            car.velocity.y *= car.friction;

            // Lateral Friction (The Key to Drift)
            // High friction = Grip (Follows car angle)
            // Low friction = Drift (Slides sideways)
            let lateralFriction = 0.8; // Grip (kill slide fast)

            if (inputs.brake) {
                lateralFriction = 0.985; // Super slippery (Handbrake)
            } else if (absLatSpeed > 2.0) {
                lateralFriction = 0.97; // Maintain drift momentum
            } else if (absLatSpeed > 0.5) {
                lateralFriction = 0.92; // Transition
            }

            // Recalculate local velocities with new friction applied ONLY to lateral component
            // To do this correctly: decompose, apply friction to lateral, recompose.

            // Decompose current (updated) world velocity
            const vFwd = car.velocity.x * forwardX + car.velocity.y * forwardY;
            const vLat = car.velocity.x * rightX + car.velocity.y * rightY;

            // Apply different frictions
            // We already applied global friction, so just handle the lateral slip specific logic
            const newLat = vLat * lateralFriction;
            // Maybe apply extra drag to forward component if drifting (scrubbing speed)
            const newFwd = vFwd; // * (isDrifting ? 0.99 : 1.0); 

            // Recompose
            car.velocity.x = forwardX * newFwd + rightX * newLat;
            car.velocity.y = forwardY * newFwd + rightY * newLat;

            // Handbrake specific strong deceleration (scrubbing all speed)
            if (inputs.brake) {
                car.velocity.x *= 0.97;
                car.velocity.y *= 0.97;
            }

            // Update scalar speed variable (for display/logic use)
            car.speed = Math.sqrt(car.velocity.x ** 2 + car.velocity.y ** 2);

            // 8. Visual Effects Triggers
            if (absLatSpeed > 1.5 || (inputs.brake && car.speed > 1)) {
                addWheelEffects(absLatSpeed);
            }

            // 9. Position Update
            car.x += car.velocity.x;
            car.y += car.velocity.y;

            // 10. Camera Dynamics (Mass-Spring-Damper)
            // Target is explicitly centered on car
            const targetX = car.x - width / 2;
            const targetY = car.y - height / 2;

            // Spring params for "Helicopter" feel (Heavy, slightly loose, overshoot capable)
            const springK = 0.03;   // Strength of pull towards target
            const damping = 0.88;   // Resistance (Inertia preservation)

            const ax = (targetX - camera.x) * springK;
            const ay = (targetY - camera.y) * springK;

            camera.vx += ax;
            camera.vy += ay;
            camera.vx *= damping;
            camera.vy *= damping;

            camera.x += camera.vx;
            camera.y += camera.vy;
        }

        // --- Particle System ---
        function createParticle(x, y, type) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 2 + car.velocity.x * 0.5,
                vy: (Math.random() - 0.5) * 2 + car.velocity.y * 0.5,
                life: 1.0,
                decay: 0.02 + Math.random() * 0.03,
                size: 2 + Math.random() * 4,
                type: type // 'smoke' or 'spark'
            });
        }

        function createSkid(x, y) {
            // Only add skid marks periodically to save performance/memory or visual clutter
            // For now, just a simple point, in a real engine we'd use a ribbon mesh
            skidMarks.push({ x, y, life: 1.0, angle: car.angle });
            if (skidMarks.length > 500) skidMarks.shift(); // Limit history
        }

        function addWheelEffects(intensity) {
            // Calculate wheel positions in world space
            const corners = [
                { x: car.wheelBase / 2, y: car.trackWidth / 2, f: true }, // Front Right
                { x: car.wheelBase / 2, y: -car.trackWidth / 2, f: true }, // Front Left
                { x: -car.wheelBase / 2, y: car.trackWidth / 2, f: false }, // Rear Right
                { x: -car.wheelBase / 2, y: -car.trackWidth / 2, f: false }  // Rear Left
            ];

            const cos = Math.cos(car.angle);
            const sin = Math.sin(car.angle);

            corners.forEach((offset) => {
                const wx = car.x + (offset.x * cos - offset.y * sin);
                const wy = car.y + (offset.x * sin + offset.y * cos);

                // Smoke generation - more intense with higher slip
                if (Math.random() < Math.min(intensity * 0.2, 0.8)) {
                    createParticle(wx, wy, 'smoke');
                }

                // Skid marks - continuous if drifting hard
                if (intensity > 2.0 || inputs.brake) {
                    createSkid(wx, wy);
                }

                // Sparks? If extremely fast drift
                if (intensity > 6.0 && Math.random() > 0.9) {
                    createParticle(wx, wy, 'spark');
                }
            });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life -= p.decay;
                p.size *= 1.05; // Expand smoke

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Fade skids
            for (let i = skidMarks.length - 1; i >= 0; i--) {
                skidMarks[i].life -= 0.005;
                if (skidMarks[i].life <= 0) skidMarks.splice(i, 1);
            }
        }

        // --- Rendering ---

        function drawCitySystem() {
            const gridSize = CITY_CONFIG.blockSize;
            // 1. Calculate Grid Range
            const startCol = Math.floor((camera.x) / gridSize) - 1;
            const endCol = Math.floor((camera.x + width) / gridSize) + 1;
            const startRow = Math.floor((camera.y) / gridSize) - 1;
            const endRow = Math.floor((camera.y + height) / gridSize) + 1;

            const renderList = [];

            // 2. Identify Renderable Entities
            for (let c = startCol; c <= endCol; c++) {
                for (let r = startRow; r <= endRow; r++) {
                    const block = getCityBlock(c, r);
                    if (block) {
                        const bx = c * gridSize;
                        const by = r * gridSize;
                        const size = gridSize - CITY_CONFIG.roadWidth;
                        const cx = bx + CITY_CONFIG.roadWidth / 2;
                        const cy = by + CITY_CONFIG.roadWidth / 2;

                        // Add Building to list
                        renderList.push({
                            type: 'building',
                            y: cy + size, // Sort by bottom edge (Z-index base)
                            x: cx,
                            baseY: cy,
                            w: size,
                            h: size, // width/depth are same for square blocks
                            height: block.height,
                            color: block.color,
                            roofColor: block.roofColor
                        });
                    }
                }
            }

            // Add Car to Render List
            // Car Y sort base: Center + half width (approx bottom)
            // Existing car drawing uses center (car.x, car.y).
            // We use simple sort based on Y.
            renderList.push({
                type: 'car',
                y: car.y + car.width / 2
            });

            // 3. Sort by Y (Painter's Algorithm)
            renderList.sort((a, b) => a.y - b.y);

            // 4. Draw Background Layer (Ground + Roads)
            drawEnhancedGround(startCol, endCol, startRow, endRow);

            // Draw Ambience (Dust/Speed lines) on top of roads, below shadows/objects
            drawDust();

            // 5. Draw Shadows (All at once on ground layer)
            // Car Shadow
            drawShadow();

            // Building Shadows
            ctx.fillStyle = CONFIG.shadowColor;
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            renderList.forEach(item => {
                if (item.type === 'building') {
                    // Simple ground shadow based on orthogonal light
                    const sx = item.height * CONFIG.lightDir.x;
                    const sy = item.height * CONFIG.lightDir.y;

                    // The shadow simply extends from the base in light direction
                    // Shadow is the "volume" extruded on ground
                    ctx.beginPath();
                    ctx.moveTo(item.x, item.baseY);
                    ctx.lineTo(item.x + item.w, item.baseY);
                    ctx.lineTo(item.x + item.w + sx, item.baseY + sy);
                    ctx.lineTo(item.x + sx, item.baseY + sy);
                    ctx.closePath();
                    // ctx.fill(); // This defines the "far" edge, but we need the whole rect

                    const shadX = item.x + sx;
                    const shadY = item.baseY + sy;
                    ctx.fillRect(shadX, shadY, item.w, item.h);
                }
            });
            ctx.restore();

            // 6. Draw Skid Marks (On top of shadows, below objects)
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            for (const s of skidMarks) {
                ctx.fillStyle = `rgba(10, 10, 10, ${s.life * 0.5})`;
                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(s.angle);
                ctx.fillRect(-4, -4, 8, 8);
                ctx.restore();
            }
            ctx.restore();

            // Draw Particles (Smoke/Sparks) - Before sorted objects (behind buildings/cars?) 
            // Original: Ground -> Shadow -> Particles -> Car. 
            // So particles are "behind" Car? Yes.
            // But they should be ABOVE shadows/skids.
            drawParticles();

            // 7. Draw Sorted Objects
            renderList.forEach(item => {
                if (item.type === 'car') {
                    // Car manages its own camera transform? No, drawCar does "ctx.translate(-camera.x...)"
                    drawParticles(); // Draw particles behind car (as originally) ??? 
                    // Original order: Ground, Dust, Shadow, Particles, Car.
                    // New order: Ground, Shadows, Skids, Sorted(Buildings, Car).
                    // Particles are tricky. Smoke should be sorted too ideally.
                    // For now, let's call drawParticles() HERE if it's the car turn?
                    // Or just call drawParticles() before the loop? 
                    // If particles are strictly "smoke from tires", they are low. 
                    // Let's draw them BEFORE the sorted loop to be safe (behind buildings).
                    drawCar();
                } else {
                    drawBuilding(item);
                }
            });
        }

        function drawEnhancedGround(sc, ec, sr, er) {
            // Background
            ctx.fillStyle = CONFIG.groundColor;
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            const gridSize = CITY_CONFIG.blockSize;
            const roadW = CITY_CONFIG.roadWidth;

            // Draw Roads (Grid Lines)
            ctx.fillStyle = '#171717'; // Dark Asphalt

            // We iterate broadly to fill the camera view
            for (let c = sc; c <= ec; c++) {
                // Vertical Roads
                const rx = c * gridSize;
                // Draw vertical strip
                // Infinite height? No, just loop range
                const y1 = sr * gridSize;
                const y2 = er * gridSize + gridSize;
                ctx.fillRect(rx, y1, roadW, y2 - y1);
            }
            for (let r = sr; r <= er; r++) {
                // Horizontal Roads
                const ry = r * gridSize;
                const x1 = sc * gridSize;
                const x2 = ec * gridSize + gridSize;
                ctx.fillRect(x1, ry, x2 - x1, roadW);
            }

            // Sidewalks / Curbs?
            // Optional detail

            ctx.restore();
        }

        function drawBuilding(b) {
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Pseudo-3D Radial Extrusion
            // Calculation of extrusion vector based on relative position to camera center
            const cameraCX = camera.x + width / 2;
            const cameraCY = camera.y + height / 2;

            // Box Center (Relative to world)
            const boxCX = b.x + b.w / 2;
            const boxCY = b.baseY + b.h / 2;

            // Relative Position
            const dx = boxCX - cameraCX;
            const dy = boxCY - cameraCY;

            // Extrusion Factor: Defines "Field of View" strength / "Height" multiplier
            // Higher factor = more perspective distortion
            // Adjusted so a 100px tall building looks reasonable
            const fovScale = 0.35;

            const extrusionX = (dx * fovScale) * (b.height / 500);
            const extrusionY = (dy * fovScale) * (b.height / 500);

            // Roof Position (Relative to Base)
            const roofX = b.x + extrusionX;
            const roofY = b.baseY + extrusionY;

            // Draw Sides (Connecting Base to Roof)
            // We draw the Convex Hull of the Base Rect and Roof Rect
            // Or simply draw the 4 faces connecting corners

            ctx.fillStyle = b.color;

            const corners = [
                { x: 0, y: 0 },
                { x: b.w, y: 0 },
                { x: b.w, y: b.h },
                { x: 0, y: b.h }
            ];

            // Draw visible faces
            // Only draw faces that are part of the "outer" shell relative to center

            // Generic approach: Draw quads connecting base corners to roof corners
            // To ensure correct overlapping (Painter's), we could sort... but simpler: 
            // Just draw the big solid block shape (Convex Hull) first?
            // Or just draw the quads. 
            // Since it's a solid colors, we can just draw the "extrusion polygon" + Roof on top.

            // Better: Draw 4 quads connecting Base Edge to Roof Edge.
            // Since we fill with solid color, internal overlapping doesn't matter much.

            ctx.beginPath();
            // Start at Base Top-Left
            corners.forEach((c, i) => {
                const nextC = corners[(i + 1) % 4];

                const b1x = b.x + c.x;
                const b1y = b.baseY + c.y;
                const b2x = b.x + nextC.x;
                const b2y = b.baseY + nextC.y;

                const r1x = roofX + c.x;
                const r1y = roofY + c.y;
                const r2x = roofX + nextC.x;
                const r2y = roofY + nextC.y;

                // Draw Quad (Side Face)
                ctx.moveTo(b1x, b1y);
                ctx.lineTo(b2x, b2y);
                ctx.lineTo(r2x, r2y);
                ctx.lineTo(r1x, r1y);
                ctx.lineTo(b1x, b1y);
            });
            ctx.fill();

            // Draw Roof
            ctx.fillStyle = b.roofColor;
            ctx.fillRect(roofX, roofY, b.w, b.h);

            // Roof Highlight (Edge)
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            ctx.strokeRect(roofX, roofY, b.w, b.h);

            // Windows / Details (Projected onto the faces?)
            // This is hard with radial extrusion without texture mapping. 
            // Skip windows for now to keep the "clean" look requested and correct geometry.

            ctx.restore();
        }

        function drawDust() {
            ctx.fillStyle = '#666';

            // We simulate dust by updating their screen position relative to camera movement
            // Ideally this should be in update loop, but doing it here for simplicity
            // To make them "World" fixed, we can just use (worldPos % viewport)

            // Actually, let's treat them as world objects wrapped in a large window around the camera
            // to avoid floating point issues? No, simplest is Screen Space Parallax.

            // Update dust positions based on car velocity (approximation of camera move)
            const dx = car.velocity.x;
            const dy = car.velocity.y;

            dustParticles.forEach(p => {
                p.x -= dx;
                p.y -= dy;

                // Wrap around screen
                if (p.x < 0) p.x += width;
                if (p.x > width) p.x -= width;
                if (p.y < 0) p.y += height;
                if (p.y > height) p.y -= height;

                // Draw
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });

            // Speed Lines (at high speed)
            if (car.speed > 10) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < 10; i++) {
                    const lx = Math.random() * width;
                    const ly = Math.random() * height;
                    const len = car.speed * 2;
                    // Draw line opposite to velocity
                    const angle = Math.atan2(car.velocity.y, car.velocity.x);
                    ctx.moveTo(lx, ly);
                    ctx.lineTo(lx - Math.cos(angle) * len, ly - Math.sin(angle) * len);
                }
                ctx.stroke();
            }
        }

        function drawShadow() {
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            const bodyHeight = 16;
            const wheelHeight = 4; // Wheels are lower to ground

            const bx = CONFIG.lightDir.x * bodyHeight;
            const by = CONFIG.lightDir.y * bodyHeight;
            const wx = CONFIG.lightDir.x * wheelHeight;
            const wy = CONFIG.lightDir.y * wheelHeight;

            // Draw shadow relative to car position
            ctx.translate(car.x, car.y);

            // We need to draw the rotated shapes at the offset positions
            ctx.fillStyle = CONFIG.shadowColor;

            // 1. Wheel Shadows (Low offset)
            const drawWheelShadow = (x, y, angle) => {
                ctx.save();
                // Apply wheel offset relative to car center, then add shadow offset
                // We rotate the wheel position offset by car angle
                const cos = Math.cos(car.angle);
                const sin = Math.sin(car.angle);
                const rx = x * cos - y * sin;
                const ry = x * sin + y * cos;

                ctx.translate(rx + wx, ry + wy); // Move to wheel world pos + shadow offset
                ctx.rotate(car.angle + angle);   // Rotate by car + steer
                ctx.fillRect(-car.wheelLength / 2, -car.wheelWidth / 2, car.wheelLength, car.wheelWidth);
                ctx.restore();
            };

            drawWheelShadow(-car.wheelBase / 2, car.trackWidth / 2, 0);
            drawWheelShadow(-car.wheelBase / 2, -car.trackWidth / 2, 0);
            drawWheelShadow(car.wheelBase / 2, car.trackWidth / 2, car.steerAngle);
            drawWheelShadow(car.wheelBase / 2, -car.trackWidth / 2, car.steerAngle);

            // 2. Body Shadow (Higher offset)
            ctx.save();
            ctx.translate(bx, by); // Body shadow offset
            ctx.rotate(car.angle);
            ctx.fillRect(-car.length / 2, -car.width / 2, car.length, car.width);
            ctx.restore();

            ctx.restore();
        }

        function drawCar() {
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            ctx.translate(car.x, car.y);
            ctx.rotate(car.angle);

            // --- Wheels (Draw first so they are under body if overlapping, though side-mount usually OK) ---
            ctx.fillStyle = CONFIG.wheelColor;
            const drawWheel = (x, y, angle) => {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.roundRect(-car.wheelLength / 2, -car.wheelWidth / 2, car.wheelLength, car.wheelWidth, 2);
                ctx.fill();
                // Rim detail
                if (car.speed < 5) {
                    ctx.fillStyle = '#444';
                    ctx.fillRect(-2, -3, 4, 6); // Axle cap
                    ctx.fillStyle = CONFIG.wheelColor;
                }
                ctx.restore();
            };

            drawWheel(-car.wheelBase / 2, car.trackWidth / 2, 0);
            drawWheel(-car.wheelBase / 2, -car.trackWidth / 2, 0);
            drawWheel(car.wheelBase / 2, car.trackWidth / 2, car.steerAngle);
            drawWheel(car.wheelBase / 2, -car.trackWidth / 2, car.steerAngle);

            // --- Body ---
            // Main Chassis
            ctx.fillStyle = CONFIG.carColor;
            ctx.beginPath();
            ctx.roundRect(-car.length / 2, -car.width / 2, car.length, car.width, 3);
            ctx.fill();

            // Roof/Cabin (Darker)
            ctx.fillStyle = '#991b1b';
            ctx.fillRect(-10, -car.width / 2 + 2, 20, car.width - 4);

            // Windshields
            ctx.fillStyle = '#111';
            ctx.fillRect(8, -car.width / 2 + 3, 2, car.width - 6); // Front
            ctx.fillRect(-9, -car.width / 2 + 3, 2, car.width - 6); // Rear

            // Brake Lights (Active when braking)
            if (inputs.brake) {
                ctx.fillStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 10;
            } else {
                ctx.fillStyle = '#500000';
                ctx.shadowBlur = 0;
            }
            ctx.fillRect(-car.length / 2, -car.width / 2 + 1, 2, 6);
            ctx.fillRect(-car.length / 2, car.width / 2 - 7, 2, 6);
            ctx.shadowBlur = 0; // Reset

            // Headlights (Simple yellow squares)
            ctx.fillStyle = '#facc15';
            ctx.fillRect(car.length / 2 - 1, -car.width / 2 + 1, 1, 5);
            ctx.fillRect(car.length / 2 - 1, car.width / 2 - 6, 1, 5);

            ctx.restore();
        }

        function drawParticles() {
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            for (const p of particles) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = p.type === 'smoke'
                    ? `rgba(200, 200, 200, ${p.life * 0.4})`
                    : `rgba(255, 200, 50, ${p.life})`;
                ctx.fill();
            }

            ctx.restore();
        }

        function loop() {
            updatePhysics();
            updateParticles();

            // Clear
            ctx.clearRect(0, 0, width, height);

            // Draw Order
            // Render World (Ground, City, Car sorted)
            drawCitySystem(); // Handles Ground, Dust, Particles, Shadows, Buildings, Car

            requestAnimationFrame(loop);
        }

        // Start
        loop();

    </script>
</body>

</html>