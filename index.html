<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcade Chase: Orthographic Drift</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #2d2d2d;
        }

        canvas {
            display: block;
        }

        .ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: monospace;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>

<body>
    <div class="ui">
        <h1 class="text-2xl font-bold text-yellow-400">DRIFT PROTOCOL</h1>
        <p class="text-sm text-gray-400">WASD / ARROWS to Drive</p>
        <p class="text-sm text-gray-400">SPACE to Brake</p>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on base

        // --- Configuration ---
        const CONFIG = {
            lightDir: { x: 1, y: 1 }, // Light coming from top-left (so shadow goes bottom-right)
            shadowColor: 'rgba(0, 0, 0, 0.4)',
            carColor: '#ef4444', // Red-500
            wheelColor: '#171717', // Neutral-900
            groundColor: '#333333',
            gridColor: '#404040',
            skidMarkColor: 'rgba(20, 20, 20, 0.3)',
            smokeColor: 'rgba(200, 200, 200, 0.5)',
        };

        // Normalize light direction
        const len = Math.sqrt(CONFIG.lightDir.x ** 2 + CONFIG.lightDir.y ** 2);
        CONFIG.lightDir.x /= len;
        CONFIG.lightDir.y /= len;

        // --- City System Configuration ---
        const CITY_CONFIG = {
            blockSize: 300,
            roadWidth: 140,
            buildingInset: 20
        };

        // Semantic District Generation (Deterministic)
        function getCityBlock(gx, gy) {
            // Simple deterministic hash
            const h = Math.abs(Math.sin(gx * 12.9898 + gy * 78.233) * 43758.5453) % 1;
            const dist = Math.sqrt(gx * gx + gy * gy);

            // District Types based on distance from center (0,0)
            let type, height, color, roofColor;

            if (dist < 4) {
                // Downtown (High density, tall)
                type = 'downtown';
                height = 120 + h * 200;
                color = h > 0.5 ? '#1e293b' : '#334155'; // Slate 800/700
                roofColor = h > 0.5 ? '#334155' : '#475569';
            } else if (dist < 8) {
                // Commercial (Medium)
                type = 'commercial';
                height = 60 + h * 100;
                color = h > 0.5 ? '#475569' : '#525252'; // Slate 600 / Neutral 600
                roofColor = h > 0.5 ? '#64748b' : '#737373';
            } else if (dist < 14) {
                // Residential (Low)
                type = 'residential';
                height = 30 + h * 50;
                color = '#78716c'; // Stone 500
                roofColor = '#a8a29e';
            } else {
                // Outskirts / Industrial
                if (h < 0.4) return null; // Empty lots
                type = 'industrial';
                height = 20 + h * 30;
                color = '#4b5563'; // Gray 600
                roofColor = '#6b7280';
            }

            return { height, color, roofColor, type, h };
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
        }

        // --- Environment Items Generation (Trees, Walls, Bushes) ---
        function getEnvironmentItems(gx, gy) {
            const items = [];
            const gridSize = CITY_CONFIG.blockSize;
            const roadW = CITY_CONFIG.roadWidth;
            const block = getCityBlock(gx, gy);

            // Hash para variação determinística
            const hash = (seed) => Math.abs(Math.sin(gx * 127.1 + gy * 311.7 + seed * 758.5) * 43758.5453) % 1;

            const bx = gx * gridSize;
            const by = gy * gridSize;

            // Posições nas calçadas (margens da estrada)
            const sidewalkPositions = [
                // Canto superior esquerdo
                { x: bx + roadW * 0.25, y: by + roadW * 0.25 },
                // Canto superior direito
                { x: bx + gridSize - roadW * 0.25, y: by + roadW * 0.25 },
                // Canto inferior esquerdo
                { x: bx + roadW * 0.25, y: by + gridSize - roadW * 0.25 },
                // Canto inferior direito
                { x: bx + gridSize - roadW * 0.25, y: by + gridSize - roadW * 0.25 },
                // Meio das calçadas
                { x: bx + gridSize / 2, y: by + roadW * 0.3 },
                { x: bx + roadW * 0.3, y: by + gridSize / 2 },
            ];

            // Árvores - nas calçadas
            for (let i = 0; i < sidewalkPositions.length; i++) {
                const h = hash(i * 10 + 1);
                if (h > 0.55) continue; // 45% chance de árvore

                const pos = sidewalkPositions[i];
                const treeHeight = 40 + hash(i * 10 + 2) * 25;
                const crownSize = 18 + hash(i * 10 + 3) * 12;

                items.push({
                    type: 'tree',
                    x: pos.x,
                    y: pos.y,
                    height: treeHeight,
                    crownSize: crownSize,
                    trunkWidth: 6 + hash(i * 10 + 4) * 4,
                    color: hash(i * 10 + 5) > 0.5 ? '#166534' : '#15803d', // Green-800/700
                    trunkColor: '#78350f' // Amber-900
                });
            }

            // Muros - bordas das propriedades (se houver prédio)
            if (block) {
                const wallH = hash(100);
                if (wallH < 0.4) { // 40% chance de muro
                    const wallHeight = 15 + hash(101) * 12;
                    const wallColor = hash(102) > 0.5 ? '#78716c' : '#a8a29e'; // Stone-500/400

                    // Muro na borda superior do prédio
                    if (hash(103) > 0.5) {
                        items.push({
                            type: 'wall',
                            x: bx + roadW / 2,
                            y: by + roadW / 2 - 8,
                            width: gridSize - roadW,
                            depth: 8,
                            height: wallHeight,
                            color: wallColor
                        });
                    }

                    // Muro na borda esquerda do prédio
                    if (hash(104) > 0.5) {
                        items.push({
                            type: 'wall',
                            x: bx + roadW / 2 - 8,
                            y: by + roadW / 2,
                            width: 8,
                            depth: gridSize - roadW,
                            height: wallHeight,
                            color: wallColor
                        });
                    }
                }
            }

            // Arbustos - junto aos muros e calçadas
            for (let i = 0; i < 4; i++) {
                const h = hash(200 + i);
                if (h > 0.35) continue; // 35% chance

                const bushX = bx + roadW * 0.4 + hash(210 + i) * (gridSize - roadW * 0.8);
                const bushY = by + roadW * 0.4 + hash(220 + i) * (gridSize - roadW * 0.8);

                // Evitar centro do bloco (onde está o prédio)
                const localX = bushX - bx;
                const localY = bushY - by;
                const margin = roadW / 2;
                const size = gridSize - roadW;
                if (localX > margin && localX < margin + size && localY > margin && localY < margin + size) {
                    continue;
                }

                items.push({
                    type: 'bush',
                    x: bushX,
                    y: bushY,
                    width: 15 + hash(230 + i) * 12,
                    depth: 12 + hash(240 + i) * 8,
                    height: 8 + hash(250 + i) * 8,
                    color: hash(260 + i) > 0.5 ? '#166534' : '#14532d' // Green-800/900
                });
            }

            return items;
        }

        // --- Game State ---
        let width, height;

        const camera = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0
        };

        const car = {
            x: 0,
            y: 0,
            width: 24,
            length: 44,
            angle: 0,          // Facing direction
            velocity: { x: 0, y: 0 },
            speed: 0,
            steerAngle: 0,     // Current wheel angle relative to car
            maxSteer: 0.6,     // ~35 degrees
            acceleration: 0.4,
            friction: 0.98,
            driftFactor: 0.92, // How much velocity aligns with facing (1.0 = no drift, 0.0 = ice)
            turnSpeed: 0.08,
            wheelBase: 28,
            trackWidth: 26,
            wheelWidth: 6,
            wheelLength: 12
        };

        const inputs = {
            up: false,
            down: false,
            left: false,
            right: false,
            brake: false
        };

        const particles = [];
        const skidMarks = []; // Persistent skid marks on the ground

        // Speed lines/dust particles for motion reference
        const dustParticles = Array.from({ length: 60 }, () => ({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            size: Math.random() * 2 + 1,
            z: Math.random() * 0.5 + 0.1 // Depth/Parallax factor (0.1 = background, 0.6 = foreground)
        }));

        // --- Resize Handling ---
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Input Handling ---
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'w') inputs.up = true;
            if (e.key === 'ArrowDown' || e.key === 's') inputs.down = true;
            if (e.key === 'ArrowLeft' || e.key === 'a') inputs.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd') inputs.right = true;
            if (e.key === ' ') inputs.brake = true;
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'w') inputs.up = false;
            if (e.key === 'ArrowDown' || e.key === 's') inputs.down = false;
            if (e.key === 'ArrowLeft' || e.key === 'a') inputs.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd') inputs.right = false;
            if (e.key === ' ') inputs.brake = false;
        });

        // --- Math Helpers ---
        function lerp(a, b, t) { return a + (b - a) * t; }
        function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

        // --- Physics Engine ---
        function checkCollision(x, y) {
            const gridSize = CITY_CONFIG.blockSize;
            const roadW = CITY_CONFIG.roadWidth;
            const size = gridSize - roadW;
            const margin = roadW / 2;

            const gx = Math.floor(x / gridSize);
            const gy = Math.floor(y / gridSize);

            // Colisão com prédio
            const block = getCityBlock(gx, gy);
            if (block) {
                const lx = x - (gx * gridSize);
                const ly = y - (gy * gridSize);
                if (lx > margin && lx < margin + size && ly > margin && ly < margin + size) {
                    return true;
                }
            }

            // Colisão com elementos do ambiente (bloco atual e vizinhos)
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const items = getEnvironmentItems(gx + dx, gy + dy);
                    for (const item of items) {
                        if (item.type === 'tree') {
                            // Colisão circular com tronco - um pouco mais generosa para evitar atravessar
                            const dist = Math.sqrt((x - item.x) ** 2 + (y - item.y) ** 2);
                            if (dist < item.trunkWidth * 0.8) return true;
                        } else if (item.type === 'wall') {
                            // Colisão retangular
                            if (x > item.x && x < item.x + item.width &&
                                y > item.y && y < item.y + item.depth) {
                                return true;
                            }
                        }
                    }
                }
            }

            return false;
        }

        function updatePhysics() {
            // ... (restante sem alteração até os corners)
            // 1. Input & Basic Handling
            const targetSteer = (inputs.right ? 1 : 0) - (inputs.left ? 1 : 0);

            // Steer logic: responsive but smooth
            // Higher speed = slower steering response (stability) unless drifting
            const steerSpeed = 0.2 - (Math.min(car.speed, 20) * 0.005);
            car.steerAngle = lerp(car.steerAngle, targetSteer * car.maxSteer, Math.max(0.05, steerSpeed));

            // Acceleration
            let throttle = 0;
            if (inputs.up) throttle = 1;
            if (inputs.down) throttle = -0.5;

            // Handbrake overrides throttle
            if (inputs.brake) throttle = 0;

            // 2. Motion Vectors
            const forwardX = Math.cos(car.angle);
            const forwardY = Math.sin(car.angle);
            const rightX = -Math.sin(car.angle);
            const rightY = Math.cos(car.angle);

            // 3. Current Velocity Analysis (Local Space)
            // Project world velocity onto car axes
            const currentFwdSpeed = car.velocity.x * forwardX + car.velocity.y * forwardY;
            const currentLatSpeed = car.velocity.x * rightX + car.velocity.y * rightY;

            // 4. Drift Logic
            // Arcade Drift Condition: Handbrake or high existing lateral slip
            // We want "Lateral Slip" to be the defining drift characteristic
            const absLatSpeed = Math.abs(currentLatSpeed);
            const isDrifting = inputs.brake || absLatSpeed > 1.5;

            // 5. Turning Physics (Yaw)
            if (car.speed > 0.1) {
                // Moving forward or backward?
                const dir = currentFwdSpeed > 0 ? 1 : -1;

                let turnMultiplier = 0.012; // Base turn rate
                if (isDrifting) {
                    turnMultiplier = 0.025; // Turn faster when drifting (oversteer ability)
                }

                // Apply rotation
                // We use car.speed to ensure we can't turn when stopped
                // But we clamp the effective speed for turning so high speed doesn't make it uncontrollable
                // However, arcade racers often allow CONSTANT turn rate regardless of speed if speed > threshold
                const effectiveTurnSpeed = Math.min(car.speed, 10);
                car.angle += car.steerAngle * effectiveTurnSpeed * turnMultiplier * dir;
            }

            // 6. Velocity Updates
            // Apply Engine Force (only forward)
            // If drifting, reduce useful forward traction slightly? Maybe not for arcade fun.
            const traction = inputs.brake ? 0 : 1;
            car.velocity.x += forwardX * throttle * car.acceleration * traction;
            car.velocity.y += forwardY * throttle * car.acceleration * traction;

            // 7. Friction & Slip
            // Forward Friction (Air resistance + Rolling resistance)
            car.velocity.x *= car.friction;
            car.velocity.y *= car.friction;

            // Lateral Friction (The Key to Drift)
            // High friction = Grip (Follows car angle)
            // Low friction = Drift (Slides sideways)
            let lateralFriction = 0.8; // Grip (kill slide fast)

            if (inputs.brake) {
                lateralFriction = 0.985; // Super slippery (Handbrake)
            } else if (absLatSpeed > 2.0) {
                lateralFriction = 0.97; // Maintain drift momentum
            } else if (absLatSpeed > 0.5) {
                lateralFriction = 0.92; // Transition
            }

            // Recalculate local velocities with new friction applied ONLY to lateral component
            // To do this correctly: decompose, apply friction to lateral, recompose.

            // Decompose current (updated) world velocity
            const vFwd = car.velocity.x * forwardX + car.velocity.y * forwardY;
            const vLat = car.velocity.x * rightX + car.velocity.y * rightY;

            // Apply different frictions
            // We already applied global friction, so just handle the lateral slip specific logic
            const newLat = vLat * lateralFriction;
            // Maybe apply extra drag to forward component if drifting (scrubbing speed)
            const newFwd = vFwd; // * (isDrifting ? 0.99 : 1.0); 

            // Recompose
            car.velocity.x = forwardX * newFwd + rightX * newLat;
            car.velocity.y = forwardY * newFwd + rightY * newLat;

            // Handbrake specific strong deceleration (scrubbing all speed)
            if (inputs.brake) {
                car.velocity.x *= 0.97;
                car.velocity.y *= 0.97;
            }

            // Update scalar speed variable (for display/logic use)
            car.speed = Math.sqrt(car.velocity.x ** 2 + car.velocity.y ** 2);

            // 8. Visual Effects Triggers
            if (absLatSpeed > 1.5 || (inputs.brake && car.speed > 1)) {
                addWheelEffects(absLatSpeed);
            }

            // 9. Position Update
            const nextX = car.x + car.velocity.x;
            const nextY = car.y + car.velocity.y;

            // Verificação de colisão nos 4 cantos do carro para precisão
            const cos = Math.cos(car.angle);
            const sin = Math.sin(car.angle);
            const hw = car.width / 2;
            const hl = car.length / 2;

            const corners = [
                { nx: nextX + (hl * cos - hw * sin), ny: nextY + (hl * sin + hw * cos) },
                { nx: nextX + (hl * cos + hw * sin), ny: nextY + (hl * sin - hw * cos) },
                { nx: nextX + (-hl * cos - hw * sin), ny: nextY + (-hl * sin + hw * cos) },
                { nx: nextX + (-hl * cos + hw * sin), ny: nextY + (-hl * sin - hw * cos) },
                { nx: nextX, ny: nextY } // Ponto central para evitar passar por troncos finos
            ];

            let hasCollided = false;
            for (const p of corners) {
                if (checkCollision(p.nx, p.ny)) {
                    hasCollided = true;
                    break;
                }
            }

            if (!hasCollided) {
                car.x = nextX;
                car.y = nextY;
            } else {
                // Resposta de colisão aprimorada: 
                // 1. Tenta mover apenas em X ou Y para permitir deslizar nas paredes
                const canMoveX = !corners.some(p => checkCollision(nextX + (p.nx - nextX), car.y + (p.ny - nextY)));
                const canMoveY = !corners.some(p => checkCollision(car.x + (p.nx - nextX), nextY + (p.ny - nextY)));

                if (canMoveX) {
                    car.x = nextX;
                    car.velocity.y *= 0.5; // Reduz velocidade lateral
                } else if (canMoveY) {
                    car.y = nextY;
                    car.velocity.x *= 0.5; // Reduz velocidade lateral
                } else {
                    // Se estiver totalmente bloqueado, repele levemente e zera
                    const pushDirX = car.x < nextX ? -1 : 1;
                    const pushDirY = car.y < nextY ? -1 : 1;
                    car.x += pushDirX * 1;
                    car.y += pushDirY * 1;
                    car.velocity.x *= -0.2; // Pequeno rebote
                    car.velocity.y *= -0.2;
                }
                car.speed = Math.sqrt(car.velocity.x ** 2 + car.velocity.y ** 2);
            }

            // 10. Camera Dynamics (Mass-Spring-Damper)
            // Target is explicitly centered on car + Helicopter Hover / Turbulence + Look-ahead
            const time = Date.now() * 0.001;
            const hoverX = Math.sin(time * 0.5) * 15 + Math.cos(time * 1.2) * 5;
            const hoverY = Math.cos(time * 0.45) * 15 + Math.sin(time * 1.3) * 5;

            // Look-ahead: Camera aims ahead of the car based on velocity
            const lookAheadFactor = 15;
            const targetX = (car.x + car.velocity.x * lookAheadFactor + hoverX) - width / 2;
            const targetY = (car.y + car.velocity.y * lookAheadFactor + hoverY) - height / 2;

            // Spring params for "Helicopter" feel (Heavy, slightly loose, overshoot capable)
            const springK = 0.03;   // Strength of pull towards target
            const damping = 0.88;   // Resistance (Inertia preservation)

            const ax = (targetX - camera.x) * springK;
            const ay = (targetY - camera.y) * springK;

            camera.vx += ax;
            camera.vy += ay;
            camera.vx *= damping;
            camera.vy *= damping;

            camera.x += camera.vx;
            camera.y += camera.vy;
        }

        // --- Particle System ---
        function createParticle(x, y, type) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 2 + car.velocity.x * 0.5,
                vy: (Math.random() - 0.5) * 2 + car.velocity.y * 0.5,
                life: 1.0,
                decay: 0.02 + Math.random() * 0.03,
                size: 2 + Math.random() * 4,
                type: type // 'smoke' or 'spark'
            });
        }

        function createSkid(x, y) {
            // Only add skid marks periodically to save performance/memory or visual clutter
            // For now, just a simple point, in a real engine we'd use a ribbon mesh
            skidMarks.push({ x, y, life: 1.0, angle: car.angle });
            if (skidMarks.length > 500) skidMarks.shift(); // Limit history
        }

        function addWheelEffects(intensity) {
            // Calculate wheel positions in world space
            const corners = [
                { x: car.wheelBase / 2, y: car.trackWidth / 2, f: true }, // Front Right
                { x: car.wheelBase / 2, y: -car.trackWidth / 2, f: true }, // Front Left
                { x: -car.wheelBase / 2, y: car.trackWidth / 2, f: false }, // Rear Right
                { x: -car.wheelBase / 2, y: -car.trackWidth / 2, f: false }  // Rear Left
            ];

            const cos = Math.cos(car.angle);
            const sin = Math.sin(car.angle);

            corners.forEach((offset) => {
                const wx = car.x + (offset.x * cos - offset.y * sin);
                const wy = car.y + (offset.x * sin + offset.y * cos);

                // Smoke generation - more intense with higher slip
                if (Math.random() < Math.min(intensity * 0.2, 0.8)) {
                    createParticle(wx, wy, 'smoke');
                }

                // Skid marks - continuous if drifting hard
                if (intensity > 2.0 || inputs.brake) {
                    createSkid(wx, wy);
                }

                // Sparks? If extremely fast drift
                if (intensity > 6.0 && Math.random() > 0.9) {
                    createParticle(wx, wy, 'spark');
                }
            });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life -= p.decay;
                p.size *= 1.05; // Expand smoke

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Fade skids
            for (let i = skidMarks.length - 1; i >= 0; i--) {
                skidMarks[i].life -= 0.005;
                if (skidMarks[i].life <= 0) skidMarks.splice(i, 1);
            }
        }

        // --- Rendering ---

        function drawCitySystem() {
            const gridSize = CITY_CONFIG.blockSize;
            // 1. Calculate Grid Range
            const startCol = Math.floor((camera.x) / gridSize) - 1;
            const endCol = Math.floor((camera.x + width) / gridSize) + 1;
            const startRow = Math.floor((camera.y) / gridSize) - 1;
            const endRow = Math.floor((camera.y + height) / gridSize) + 1;

            const renderList = [];

            // 2. Identify Renderable Entities
            for (let c = startCol; c <= endCol; c++) {
                for (let r = startRow; r <= endRow; r++) {
                    const block = getCityBlock(c, r);
                    if (block) {
                        const bx = c * gridSize;
                        const by = r * gridSize;
                        const size = gridSize - CITY_CONFIG.roadWidth;
                        const cx = bx + CITY_CONFIG.roadWidth / 2;
                        const cy = by + CITY_CONFIG.roadWidth / 2;

                        // Add Building to list
                        renderList.push({
                            type: 'building',
                            y: cy + size, // Sort by bottom edge (Z-index base)
                            x: cx,
                            baseY: cy,
                            w: size,
                            h: size, // width/depth are same for square blocks
                            height: block.height,
                            color: block.color,
                            roofColor: block.roofColor
                        });
                    }

                    // Add Environment Items (Trees, Walls, Bushes)
                    const envItems = getEnvironmentItems(c, r);
                    for (const item of envItems) {
                        if (item.type === 'tree') {
                            renderList.push({
                                type: 'tree',
                                y: item.y + item.crownSize / 2,
                                ...item
                            });
                        } else if (item.type === 'wall') {
                            renderList.push({
                                type: 'wall',
                                y: item.y + item.depth,
                                ...item
                            });
                        } else if (item.type === 'bush') {
                            renderList.push({
                                type: 'bush',
                                y: item.y + item.depth / 2,
                                ...item
                            });
                        }
                    }
                }
            }

            // Add Car to Render List
            // Car Y sort base: Center + half width (approx bottom)
            // Existing car drawing uses center (car.x, car.y).
            // We use simple sort based on Y.
            renderList.push({
                type: 'car',
                y: car.y + car.width / 2
            });

            // 3. Sort by Y (Painter's Algorithm)
            renderList.sort((a, b) => a.y - b.y);

            // 4. Draw Background Layer (Ground + Roads)
            drawEnhancedGround(startCol, endCol, startRow, endRow);

            // Draw Ambience (Dust/Speed lines) on top of roads, below shadows/objects
            drawDust();

            // 5. Draw Shadows (All at once on ground layer)
            // Car Shadow
            drawShadow();

            // Building and Environment Shadows
            ctx.fillStyle = CONFIG.shadowColor;
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            renderList.forEach(item => {
                if (item.type === 'building') {
                    // Simple ground shadow based on orthogonal light
                    const sx = item.height * CONFIG.lightDir.x;
                    const sy = item.height * CONFIG.lightDir.y;

                    // The shadow simply extends from the base in light direction
                    // Shadow is the "volume" extruded on ground
                    ctx.beginPath();
                    ctx.moveTo(item.x, item.baseY);
                    ctx.lineTo(item.x + item.w, item.baseY);
                    ctx.lineTo(item.x + item.w + sx, item.baseY + sy);
                    ctx.lineTo(item.x + sx, item.baseY + sy);
                    ctx.closePath();
                    // ctx.fill(); // This defines the "far" edge, but we need the whole rect

                    const shadX = item.x + sx;
                    const shadY = item.baseY + sy;
                    ctx.fillRect(shadX, shadY, item.w, item.h);
                } else if (item.type === 'tree') {
                    // Sombra combinada (Tronco + Copa)
                    const sx = item.height * CONFIG.lightDir.x * 0.6;
                    const sy = item.height * CONFIG.lightDir.y * 0.6;

                    // 1. Unificar sombra do tronco e da copa em um único path para evitar sobreposição de alpha
                    const tw = item.trunkWidth / 2;
                    ctx.beginPath();
                    // Tronco
                    ctx.moveTo(item.x - tw, item.y);
                    ctx.lineTo(item.x + tw, item.y);
                    ctx.lineTo(item.x + tw + sx, item.y + sy);
                    ctx.lineTo(item.x - tw + sx, item.y + sy);
                    ctx.closePath();
                    // Copa
                    ctx.ellipse(item.x + sx, item.y + sy, item.crownSize, item.crownSize * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (item.type === 'wall') {
                    // Sombra retangular
                    const sx = item.height * CONFIG.lightDir.x;
                    const sy = item.height * CONFIG.lightDir.y;
                    ctx.fillRect(item.x + sx, item.y + sy, item.width, item.depth);
                } else if (item.type === 'bush') {
                    // Sombra elíptica pequena
                    const sx = item.height * CONFIG.lightDir.x * 0.5;
                    const sy = item.height * CONFIG.lightDir.y * 0.5;
                    ctx.beginPath();
                    ctx.ellipse(item.x + sx, item.y + sy, item.width / 2, item.depth / 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.restore();

            // 6. Draw Skid Marks (On top of shadows, below objects)
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            for (const s of skidMarks) {
                ctx.fillStyle = `rgba(10, 10, 10, ${s.life * 0.5})`;
                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(s.angle);
                ctx.fillRect(-4, -4, 8, 8);
                ctx.restore();
            }
            ctx.restore();

            // Draw Particles (Smoke/Sparks) - Before sorted objects (behind buildings/cars?) 
            // Original: Ground -> Shadow -> Particles -> Car. 
            // So particles are "behind" Car? Yes.
            // But they should be ABOVE shadows/skids.
            drawParticles();

            // 7. Draw Sorted Objects
            renderList.forEach(item => {
                if (item.type === 'car') {
                    drawParticles();
                    drawCar();
                } else if (item.type === 'building') {
                    drawBuilding(item);
                } else if (item.type === 'tree') {
                    drawTree(item);
                } else if (item.type === 'wall') {
                    drawWall(item);
                } else if (item.type === 'bush') {
                    drawBush(item);
                }
            });
        }

        function drawEnhancedGround(sc, ec, sr, er) {
            // Background
            ctx.fillStyle = CONFIG.groundColor;
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            const gridSize = CITY_CONFIG.blockSize;
            const roadW = CITY_CONFIG.roadWidth;

            // Draw Roads (Grid Lines)
            ctx.fillStyle = '#171717'; // Dark Asphalt

            // We iterate broadly to fill the camera view
            for (let c = sc; c <= ec; c++) {
                // Vertical Roads
                const rx = c * gridSize;
                // Draw vertical strip
                // Infinite height? No, just loop range
                const y1 = sr * gridSize;
                const y2 = er * gridSize + gridSize;
                ctx.fillRect(rx, y1, roadW, y2 - y1);
            }
            for (let r = sr; r <= er; r++) {
                // Horizontal Roads
                const ry = r * gridSize;
                const x1 = sc * gridSize;
                const x2 = ec * gridSize + gridSize;
                ctx.fillRect(x1, ry, x2 - x1, roadW);
            }

            // Sidewalks / Curbs?
            // Optional detail

            ctx.restore();
        }

        function drawBuilding(b) {
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Pseudo-3D Radial Extrusion
            const cameraCX = camera.x + width / 2;
            const cameraCY = camera.y + height / 2;
            const boxCX = b.x + b.w / 2;
            const boxCY = b.baseY + b.h / 2;
            const dx = boxCX - cameraCX;
            const dy = boxCY - cameraCY;

            const fovScale = 0.35 * (1 + car.speed * 0.015); // FOV aumenta com a velocidade
            const extrusionX = (dx * fovScale) * (b.height / 500);
            const extrusionY = (dy * fovScale) * (b.height / 500);

            const roofX = b.x + extrusionX;
            const roofY = b.baseY + extrusionY;

            // Draw Sides (Connecting Base to Roof)
            // Render each wall quad individually to ensure solidity and avoid winding issues
            const baseCorners = [
                { x: b.x, y: b.baseY },
                { x: b.x + b.w, y: b.baseY },
                { x: b.x + b.w, y: b.baseY + b.h },
                { x: b.x, y: b.baseY + b.h }
            ];

            const roofCorners = [
                { x: roofX, y: roofY },
                { x: roofX + b.w, y: roofY },
                { x: roofX + b.w, y: roofY + b.h },
                { x: roofX, y: roofY + b.h }
            ];

            // Determine wall visibility and draw
            for (let i = 0; i < 4; i++) {
                const next = (i + 1) % 4;

                // Slightly darker walls to give depth perception
                ctx.fillStyle = i % 2 === 0 ? b.color : shadeColor(b.color, -10);

                ctx.beginPath();
                ctx.moveTo(baseCorners[i].x, baseCorners[i].y);
                ctx.lineTo(baseCorners[next].x, baseCorners[next].y);
                ctx.lineTo(roofCorners[next].x, roofCorners[next].y);
                ctx.lineTo(roofCorners[i].x, roofCorners[i].y);
                ctx.closePath();
                ctx.fill();
            }

            // Draw Roof
            ctx.fillStyle = b.roofColor;
            ctx.fillRect(roofX, roofY, b.w, b.h);

            // Roof Highlight (Edge)
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = 1;
            ctx.strokeRect(roofX, roofY, b.w, b.h);

            ctx.restore();
        }

        // Helper for subtle depth
        function shadeColor(hex, percent) {
            const rgb = hexToRgb(hex);
            if (!rgb) return hex;
            const f = (val) => Math.max(0, Math.min(255, val + percent));
            return `rgb(${f(rgb.r)},${f(rgb.g)},${f(rgb.b)})`;
        }

        // --- Draw Tree (Copa esférica + Tronco) ---
        function drawTree(t) {
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Pseudo-3D extrusion based on camera
            const cameraCX = camera.x + width / 2;
            const cameraCY = camera.y + height / 2;
            const dx = t.x - cameraCX;
            const dy = t.y - cameraCY;

            const fovScale = 0.25 * (1 + car.speed * 0.015); // FOV aumenta com a velocidade
            const extrusionX = (dx * fovScale) * (t.height / 300);
            const extrusionY = (dy * fovScale) * (t.height / 300);

            // --- Tronco 3D Extrudado ---
            const tw = t.trunkWidth / 2;
            const baseCorners = [
                { x: t.x - tw, y: t.y - tw },
                { x: t.x + tw, y: t.y - tw },
                { x: t.x + tw, y: t.y + tw },
                { x: t.x - tw, y: t.y + tw }
            ];

            const topX = t.x + extrusionX;
            const topY = t.y + extrusionY;
            const topCorners = [
                { x: topX - tw, y: topY - tw },
                { x: topX + tw, y: topY - tw },
                { x: topX + tw, y: topY + tw },
                { x: topX - tw, y: topY + tw }
            ];

            // Desenhar faces do tronco para volume
            for (let i = 0; i < 4; i++) {
                const next = (i + 1) % 4;
                ctx.fillStyle = i % 2 === 0 ? t.trunkColor : shadeColor(t.trunkColor, -15);
                ctx.beginPath();
                ctx.moveTo(baseCorners[i].x, baseCorners[i].y);
                ctx.lineTo(baseCorners[next].x, baseCorners[next].y);
                ctx.lineTo(topCorners[next].x, topCorners[next].y);
                ctx.lineTo(topCorners[i].x, topCorners[i].y);
                ctx.closePath();
                ctx.fill();
            }

            // Copa (topo com extrusion)
            const crownX = topX;
            const crownY = topY;

            // Copa principal
            ctx.fillStyle = t.color;
            ctx.beginPath();
            ctx.ellipse(crownX, crownY, t.crownSize, t.crownSize * 0.85, 0, 0, Math.PI * 2);
            ctx.fill();

            // Destaque claro na copa
            ctx.fillStyle = shadeColor(t.color, 15);
            ctx.beginPath();
            ctx.ellipse(crownX - t.crownSize * 0.2, crownY - t.crownSize * 0.2, t.crownSize * 0.5, t.crownSize * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // --- Draw Wall (Paralelepípedo baixo) ---
        function drawWall(w) {
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Pseudo-3D extrusion
            const cameraCX = camera.x + width / 2;
            const cameraCY = camera.y + height / 2;
            const boxCX = w.x + w.width / 2;
            const boxCY = w.y + w.depth / 2;
            const dx = boxCX - cameraCX;
            const dy = boxCY - cameraCY;

            const fovScale = 0.3;
            const extrusionX = (dx * fovScale) * (w.height / 200);
            const extrusionY = (dy * fovScale) * (w.height / 200);

            const topX = w.x + extrusionX;
            const topY = w.y + extrusionY;

            // Paredes laterais
            const baseCorners = [
                { x: w.x, y: w.y },
                { x: w.x + w.width, y: w.y },
                { x: w.x + w.width, y: w.y + w.depth },
                { x: w.x, y: w.y + w.depth }
            ];

            const topCorners = [
                { x: topX, y: topY },
                { x: topX + w.width, y: topY },
                { x: topX + w.width, y: topY + w.depth },
                { x: topX, y: topY + w.depth }
            ];

            for (let i = 0; i < 4; i++) {
                const next = (i + 1) % 4;
                ctx.fillStyle = i % 2 === 0 ? w.color : shadeColor(w.color, -10);
                ctx.beginPath();
                ctx.moveTo(baseCorners[i].x, baseCorners[i].y);
                ctx.lineTo(baseCorners[next].x, baseCorners[next].y);
                ctx.lineTo(topCorners[next].x, topCorners[next].y);
                ctx.lineTo(topCorners[i].x, topCorners[i].y);
                ctx.closePath();
                ctx.fill();
            }

            // Topo
            ctx.fillStyle = shadeColor(w.color, 10);
            ctx.fillRect(topX, topY, w.width, w.depth);

            ctx.restore();
        }

        // --- Draw Bush (Elipsoide baixo) ---
        function drawBush(b) {
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Pseudo-3D extrusion
            const cameraCX = camera.x + width / 2;
            const cameraCY = camera.y + height / 2;
            const dx = b.x - cameraCX;
            const dy = b.y - cameraCY;

            const fovScale = 0.2;
            const extrusionX = (dx * fovScale) * (b.height / 150);
            const extrusionY = (dy * fovScale) * (b.height / 150);

            const topX = b.x + extrusionX;
            const topY = b.y + extrusionY;

            // Base
            ctx.fillStyle = shadeColor(b.color, -15);
            ctx.beginPath();
            ctx.ellipse(b.x, b.y, b.width / 2, b.depth / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Topo com extrusion
            ctx.fillStyle = b.color;
            ctx.beginPath();
            ctx.ellipse(topX, topY, b.width / 2 * 0.9, b.depth / 2 * 0.9, 0, 0, Math.PI * 2);
            ctx.fill();

            // Destaque
            ctx.fillStyle = shadeColor(b.color, 12);
            ctx.beginPath();
            ctx.ellipse(topX - b.width * 0.1, topY - b.depth * 0.1, b.width / 4, b.depth / 4, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawDust() {
            ctx.fillStyle = '#666';

            // We simulate dust by updating their screen position relative to camera movement
            // Ideally this should be in update loop, but doing it here for simplicity
            // To make them "World" fixed, we can just use (worldPos % viewport)

            // Actually, let's treat them as world objects wrapped in a large window around the camera
            // to avoid floating point issues? No, simplest is Screen Space Parallax.

            // Update dust positions based on car velocity (approximation of camera move)
            const dx = car.velocity.x;
            const dy = car.velocity.y;

            dustParticles.forEach(p => {
                // Parallax move: foreground moves faster
                p.x -= dx * p.z;
                p.y -= dy * p.z;

                // Wrap around screen
                if (p.x < -50) p.x += width + 100;
                if (p.x > width + 50) p.x -= width + 100;
                if (p.y < -50) p.y += height + 100;
                if (p.y > height + 50) p.y -= height + 100;

                // Draw with opacity based on depth
                ctx.globalAlpha = p.z * 1.5;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            ctx.globalAlpha = 1.0;

            // Speed Lines (at high speed)
            if (car.speed > 10) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < 10; i++) {
                    const lx = Math.random() * width;
                    const ly = Math.random() * height;
                    const len = car.speed * 2;
                    // Draw line opposite to velocity
                    const angle = Math.atan2(car.velocity.y, car.velocity.x);
                    ctx.moveTo(lx, ly);
                    ctx.lineTo(lx - Math.cos(angle) * len, ly - Math.sin(angle) * len);
                }
                ctx.stroke();
            }
        }

        function drawShadow() {
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            const bodyHeight = 16;
            const wheelHeight = 4; // Wheels are lower to ground

            const bx = CONFIG.lightDir.x * bodyHeight;
            const by = CONFIG.lightDir.y * bodyHeight;
            const wx = CONFIG.lightDir.x * wheelHeight;
            const wy = CONFIG.lightDir.y * wheelHeight;

            // Draw shadow relative to car position
            ctx.translate(car.x, car.y);

            // We need to draw the rotated shapes at the offset positions
            ctx.fillStyle = CONFIG.shadowColor;

            // 1. Wheel Shadows (Low offset)
            const drawWheelShadow = (x, y, angle) => {
                ctx.save();
                // Apply wheel offset relative to car center, then add shadow offset
                // We rotate the wheel position offset by car angle
                const cos = Math.cos(car.angle);
                const sin = Math.sin(car.angle);
                const rx = x * cos - y * sin;
                const ry = x * sin + y * cos;

                ctx.translate(rx + wx, ry + wy); // Move to wheel world pos + shadow offset
                ctx.rotate(car.angle + angle);   // Rotate by car + steer
                ctx.fillRect(-car.wheelLength / 2, -car.wheelWidth / 2, car.wheelLength, car.wheelWidth);
                ctx.restore();
            };

            drawWheelShadow(-car.wheelBase / 2, car.trackWidth / 2, 0);
            drawWheelShadow(-car.wheelBase / 2, -car.trackWidth / 2, 0);
            drawWheelShadow(car.wheelBase / 2, car.trackWidth / 2, car.steerAngle);
            drawWheelShadow(car.wheelBase / 2, -car.trackWidth / 2, car.steerAngle);

            // 2. Body Shadow (Higher offset)
            ctx.save();
            ctx.translate(bx, by); // Body shadow offset
            ctx.rotate(car.angle);
            ctx.fillRect(-car.length / 2, -car.width / 2, car.length, car.width);
            ctx.restore();

            ctx.restore();
        }

        function drawCar() {
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            ctx.translate(car.x, car.y);
            ctx.rotate(car.angle);

            // --- Wheels (Draw first so they are under body if overlapping, though side-mount usually OK) ---
            ctx.fillStyle = CONFIG.wheelColor;
            const drawWheel = (x, y, angle) => {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.roundRect(-car.wheelLength / 2, -car.wheelWidth / 2, car.wheelLength, car.wheelWidth, 2);
                ctx.fill();
                // Rim detail
                if (car.speed < 5) {
                    ctx.fillStyle = '#444';
                    ctx.fillRect(-2, -3, 4, 6); // Axle cap
                    ctx.fillStyle = CONFIG.wheelColor;
                }
                ctx.restore();
            };

            drawWheel(-car.wheelBase / 2, car.trackWidth / 2, 0);
            drawWheel(-car.wheelBase / 2, -car.trackWidth / 2, 0);
            drawWheel(car.wheelBase / 2, car.trackWidth / 2, car.steerAngle);
            drawWheel(car.wheelBase / 2, -car.trackWidth / 2, car.steerAngle);

            // --- Body ---
            // Main Chassis
            ctx.fillStyle = CONFIG.carColor;
            ctx.beginPath();
            ctx.roundRect(-car.length / 2, -car.width / 2, car.length, car.width, 3);
            ctx.fill();

            // Roof/Cabin (Darker)
            ctx.fillStyle = '#991b1b';
            ctx.fillRect(-10, -car.width / 2 + 2, 20, car.width - 4);

            // Windshields
            ctx.fillStyle = '#111';
            ctx.fillRect(8, -car.width / 2 + 3, 2, car.width - 6); // Front
            ctx.fillRect(-9, -car.width / 2 + 3, 2, car.width - 6); // Rear

            // Brake Lights (Active when braking)
            if (inputs.brake) {
                ctx.fillStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 10;
            } else {
                ctx.fillStyle = '#500000';
                ctx.shadowBlur = 0;
            }
            ctx.fillRect(-car.length / 2, -car.width / 2 + 1, 2, 6);
            ctx.fillRect(-car.length / 2, car.width / 2 - 7, 2, 6);
            ctx.shadowBlur = 0; // Reset

            // Headlights (Simple yellow squares)
            ctx.fillStyle = '#facc15';
            ctx.fillRect(car.length / 2 - 1, -car.width / 2 + 1, 1, 5);
            ctx.fillRect(car.length / 2 - 1, car.width / 2 - 6, 1, 5);

            ctx.restore();
        }

        function drawParticles() {
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            for (const p of particles) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = p.type === 'smoke'
                    ? `rgba(200, 200, 200, ${p.life * 0.4})`
                    : `rgba(255, 200, 50, ${p.life})`;
                ctx.fill();
            }

            ctx.restore();
        }

        function loop() {
            updatePhysics();
            updateParticles();

            // Clear with dynamic zoom
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            // Zoom dinâmico baseado na velocidade
            const zoom = 1 / (1 + car.speed * 0.004);
            ctx.translate(width / 2, height / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-width / 2, -height / 2);

            // Draw Order
            // Render World (Ground, City, Car sorted)
            drawCitySystem(); // Handles Ground, Dust, Particles, Shadows, Buildings, Car
            ctx.restore();

            requestAnimationFrame(loop);
        }

        // Start
        loop();

    </script>
</body>

</html>